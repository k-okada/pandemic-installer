
# Pandemic Installer 仕組み

# なぜ仕組みを知りたいのか?

 * どうせ色々なトラブルが起きる．結局は一段下の仕組みを知らないと解決できないことがある．仕組みを知らないと頭をかきむしるしかないことが仕組みを知れば，一般的な知識としても役に立つし，トラブルも解決できる．
 * ソフト的なトラブルが起きなくても失敗することがある．ハードディスクがのろい，ネットワークがおかしいなど．仕組みと機能をよく知っていれば一からやり直すより効率的な解決策が見つかることもある．
 * どこをどう改善したいいいかのアイデアが出る．知っていれば簡単に改善できることも，ブラックボックスとして使っているだけだと見逃してしまったり，思考停止してしまったりする

# Pandemic 以前の基本

 * 要するに必要なことは，一台のインストール済みPCのハードディスクを他のマシンに一斉にコピーすること，だけである．それを，マスターがディスクを読む，ネットワークを経由して他のマシンに送る，受け取った他のマシンはそれをディスクに書く，ということをしているだけ．
 * だがハードディスクをコピーすると言っても，ファイルシステムを通してコピーするのではダメ．それだと，いわゆるファイルシステム以外の部分---パーティションに関する情報とか---をコピーすることが出来ないし，LinuxからWindowsのパーティションをコピーすることも難しい(マウント出来なくはないが，トリッキー)
 * よって，ハードディスクは，マウントしていない状態で，デバイスディスク(/dev/sdaとか)を直接アクセスする．これ自体はLinuxであれば普通にopen, readで読めてしまう．これでいわゆる「ディスクまるごとコピー」ができる
 * これをやるためには当然のことながら，コピー対象のハードディスクにインストールされているOSを立ち上げてはダメで，OSを別のメディアから起動して，ハードディスクはマウントされていない状態で起動する必要がある．
  * マスターPCはUSBメモリから起動する
  * クライアントPCは，ネットワーク経由で起動する(PXE Boot); クライアントPCをUSBメモリから起動することも原理的には可能だが，コピーする台数の文だけUSBメモリを作るというのはあまりやりたくない．そこで，マスターPCを，他のPCをPXE Bootさせるためのサーバとして用い，クライアントをPXE Bootさせる．Pandemic Installerがやっていることの中で面倒でややこしいのは大部分はここに起因する．とはいえPXE BootはOS非依存な標準的プロトコルで，Linux (Unix)には古くからPXE Bootのためのツールが有り，その仕組みを理解してしまえば，Pandemic Installerのやっていることは大部分理解できたも同然である．
 * そこで以降しばらくPXE Bootの仕組みについて説明する
 * マスターで以下のサーバが立ち上がっていなくてはならない．いずれも標準的なサーバである
  * DHCP server
  * tftp server
  * NFS server
 * PXE bootさせたいクライアントは，firmware (BIOS/UEFI)の起動画面で，ネットワーク経由の起動を選択すれば良い(setup画面に入って起動順序を変更しても良いし，それよりも一回だけえらぶ機能を使っても良い．例えば前者はF2, 後者はF12だったりすることが多い)．
 * ネットワーク経由の起動を選択すると，そのマシンはDHCPクライアントとなって，サーバからの返答を待つ．DHCPサーバが返事をすれば次へ進める．ここで先へ進めない場合，マスターでDHCP サーバがきちんと動いているかを見る．また，/var/log/syslogなどを見て，DHCP関連のやりとりをチェック，監視するとよい(もちろんPandemic マスターではDHCPサーバは立ち上がっている「はず」だが，それが何故か死んでいるということも往々にしてある)．関連ファイル:
  * /etc/init.d/isc-dhcp-server (DHCPサーバの起動ファイル)
  * /etc/dhcp/dhcpd.conf (DHCPサーバの設定ファイル)
  * /etc/default/isc-dhcp-server (DHCPサーバの設定ファイル)
 * DHCPサーバは，普通のDHCPクライアントにはIPアドレスなどを返して終わりだが，PXE Bootさせるためにはもう何段階か必要で，PXE Bootしたクライアントに対しては，小さなカーネルを送り込む．その小さなカーネルを送り込む役目をになっているのが次のtftpサーバであり，DHCPサーバが「お前はこいつからカーネルをもらえ」とクライアントに指示するための魔法が，dhcp serverのconfig fileにある次のような行: 
```
  next-server 10.0.xxx.xxx
```
経験上，トラブル時にこのtftpサーバがなぜかずっこけているということが多い．そうなっていたらやはりクライアントは起動しない．直し方はtftpサーバを再起動する．関連ファイル:
  * /etc/init.d/tftp-hpa (tftpサーバの起動ファイル. もしかしたら名前違うかも)
 * 無事tftp経由でカーネルが送り込まれたら次は，クライアントがルートファイルシステムをネットワーク(NFS)経由でマウントする．そのためにマスター上でNFSサーバが動いている必要がある．
  * プロセス名: ps auxww | grep nfs とかで見ればわかる
  * /etc/init.d/nfs-kernel-server: NFSサーバの起動スクリプト
  * ...
 * NFSマウントがすむと無事クライアントは立ち上がり，例のGUI画面まで進むはずである．
 * このPXE Boot -> tftp -> NFSマウント，という一連の流れが最もトラブルが起きやすい所．しかしこの部分はPandemic 固有の作り込みはほとんど無く，通常のネットワークブートをやるために，DHCPサーバ, tftpサーバ，NFSサーバを設定しているだけである．トラブルシュートはそれらのサーバの設定方法や，一般的なトラブルシュート方法を学べばよい．もちろん色々なイベントは/var/log/syslog に逐一記録されるので，物事がうまく行っているか確かめたければそれを適宜見るのも良い．

# outbreak コマンド: Pandemic Installer本体
 * 以降，無事クライアントが立ち上がったあとの話
 * 作業としては，端末を開き
```
$ sudo su -
# ./outbreak
```
で良いということになっている．以降この，outbreakがやっていることを説明する．なお，outbreak自身はただのシェルスクリプトです．
 * 最初に述べたとおりここまで来たらあとやるべきことは単に，マスターの/dev/sdaを残りのマシンの/dev/sdaにネットワーク経由でコピーすることだけである．
 * そのために，各マシンの上で一つずつそのためのプロセス(マスター上ではblkcpm, 残りのマシンではblkcpcというコマンド)を立ち上げ，blkcpmが送ったデータをblkcpcが書き込むだけ．blkcpm, blkcpcたちはソケットでリング状につながっている．blkcp{m,c}は，block-copy-{master,client}の意味．ファイルのある一部のブロックを切り取って他のマシンの同じ位置に書き込む，ということをするコマンドである．
 * blkcpm, blkcpcでプロセスを立ち上げてそれらをソケットでつなげるために，GXPという並列シェルの一種を使っている(gxpcコマンド)．
 * blkcpm, blkcpc はGXPに同梱されているコマンドである．
 * outbreakは，適当なブロックサイズ(100MBとか)を定め，/dev/sdaの先頭から決められたサイズずつ，繰り返しコピーする．気分としては，
  * 0-100MB部分をコピー
  * 100MB-200MB部分をコピー
  * 200MB-300MB部分をコピー
  * ...
ということを順にやっていく．
言い換えれば0-100MB部分を全員がコピーし終えるまでは誰も先へ進まない(いわば同期実行; 旧版との違い)．こうすることで，途中で誰かが脱落した時の処理が単純になるし確実性が増す．outbreakコマンド内のcopy_blockという関数が，一個のブロックをコピーする関数である．
 * 途中で誰かが失敗したらどうなるか? 基本はブロックを最小単位として，失敗したブロックからやり直せば良い．例えば，1200MB-1300MBのコピーでエラーが発生したら，もう一度1200MB目からやり直せば良い．一時的な不調であれば文字通りそこからやり直せば良い(そのための具体的方法は後述)し，どれかのマシンがハードウェア的に故障したのであればそいつを抜かして続きをやれば良い．
 * outbreakは，途中で失敗した時の対処を自動的に，それなりに賢くやるように「書かれては」いる．目標としては，多数台のうちの一部が故障しても残りは最後まで走り切ることを目指して書かれている．が，イコールそのような実績がいっぱいあるというわけではない．以下に，どのように動作するつもりかを書いておく
  * まず，多数のプロセスがリング上につながっている関係で，実際には一台にネットワーク不達障害が起きたりすると，そのブロックのコピーは事実上全てのノードで失敗する．ハードディスク障害の場合，一台だけが失敗して残りは成功することも考えられるが，いずれにせよ，コマンドがうまく行かない -> そのマシンが故障した，ということにはならない
  * そこで，まずブロックをコピーしてみて全員成功しなかった場合，全員に対して到達チェックをする(gxpc ping)．到達しなかったものを除外する
  * 到達したものに対してハードディスクへの（ゴミデータで）書き込みチェックをする．失敗したものを除外する
  * 残されたものでブロックのコピーを再試行する
 * ブロックのコピーを試みるコマンドは，
```
gxpc --timeout ${timeout} mw --master blkcpm "blkcpc --pkt_sz ${pkt_sz} --creat ${creat} --trunc ${trunc} --read_fault ${read_fault} --send_fault ${send_fault} --recv_fault ${recv_fault} --write_fault ${write_fault} --close_fault ${close_fault} --closesocket_fault ${closesocket_fault} --block_on_fault ${block_on_fault} --min_receivers 0 --write 1 --transfer 0 --range ${from_offs}:${to_offs} ${src_file} ${dst_file}"
```
のような形．異様に引数が多くて汚いが，肝心なのは --range および src_file, dst_file. あとは後々の性能チューンのために，一度に転送するサイズを--pkt_sz で指定できるように鳴っていたりする．残りの--xxx_fault などのオプションは，各操作でわざとある確率でエラーを起こさせるというオプションで，耐故障性のテスト時に用いるもの．デフォルトは0で，もちろんテスト時以外は0でよい．

# エラー発生時の挙動

 * エラーにはディスク失敗にはハード故障，ネットワーク故障から，ソフトのバグまであらゆる原因が考えられるので，必ずこうすればよいという公式はない．
 * 結局の所やっておくといいのは，このソフトがどのように動作することを意図して書かれていて，エラーが起きた時に何が表示されるはずかを知っておく，ということである．
 * まず，blkcpc/blkcpm 自身は，ネットワークからデータを受け取る，送る，ディスクから読む，ディスクに書く，などでエラーが発生したらエラー終了するようになっており，来る予定だった全てのデータが来て，それが正常にファイルにかかれた時のみ，正常終了するようになっている．outbreakはブロックをコピーする際，blkcpcが全てのクライアント上で成功したか否かを検査するようになっている．
 * 検査の結果一部でもエラーがあるとわかったら次のことをする
  * 全てのクライアントに(gxpc ping というコマンドで)到達可能かを検査
  * 到達可能であったクライアントに対し，書き込み先ディスクの同じ場所(コピーをしようとしていた場所)にゴミを書き込んで，書き込めるかを検査
  * 以上をクリアしたクライアントに対してもう一度コピーを試みる
  * 以上をくぐり抜けたクライアントは残し，残りは脱落させ，次のブロックへ進む
 * 脱落したクライアントが多くなり過ぎたらたとえ何台かうまく行っているのが残っていたとしても全体を終了させる．これは例えば30台でコピーを始めたのがあっという間に5台に減ってしまった場合，5台で残りを頑張るより，むしろ初めから(30台で)やり直した方が多くの場合有益だろうという判断による．どういう場合に残された台数で頑張って，どういう場合に全体を終了させるかは少しややこしい式を使って計算しているが，要するに，ある程度コピーが進んでいたら少ない台数でも残りで最後まで頑張る，まだ始めたばかりであればさっさと諦める，という方針で決められている．
 * 全体が終了した場合，本来は上記の方針で「頭からやってもいいんじゃね」と判断されたはずなので，大概の場合最初からやり直すことに大した心理的ロスは感じないはずである（感じる場所で全体が終了したら計算式がおかしいか，実装のバグの可能性あり）
 * 一方で，失敗した続きからやり直すためのオプションもある(--resume --ignore_timestamps)．やるべきことは，outbreakをもう一度発行した際に各クライアントがどこまで進んでいたかを調べ，その最小値を計算してそこから先をやり直す，ということである．そのためにoutbreakはコピー中に各クライアントに対してどこまでコピーが進んだかというファイル(チェックポイントファイルckpt.db; マスターにひとつだけある)を更新している．--resume --ignore_timestamp を与えると，そのckpt.dbを見て各クライアントがどこまでコピーされているかを調べ，その最小値を計算し，それ以降をコピーするようになる．したがって，以前失敗した場所からやり直したければ，
```
./outbreak --resume --ignore_timestamp
```
とする．ただしこれを使う前に，「最初からやり直すと比べて本当に大きな時間の節約になるか」は自問したほうが良い．残り時間が少ない時は全体終了しにくくなっている．
 * なお，--resumeはチェックポイントファイルを使えという意味．では，--ignore_timestamp の意味は何かというと，チェックポイントファイルを検索する際，クライアントのIPアドレスとファイル名だけで検索するという意味．--ignore_timestamp を付けた場合，書き込み先ファイルのmtimeがchpt.dbに記録されたものと等しいかも検査する．--ignore_timestampを付けない場合，同じIPアドレスだが実はマシンが入れ替わっていた場合に，その入れ替わりを検出できない．mtimeの一致を見ることで，おそらくそのディスクが，以前失敗した時のディスクであることを検出できる(だろう)と考えている．．．のだが，--ignore_timestampを付けないと，なぜか0バイト目からコピーを始めようとしてしまう場合が観測されていて，原因はまだよくわかっていない．本当は，常に --resume (だけ)を与えれば所望の動作をしてくれるはずなのだが，現状はなぜか，--ignore_timestamp を付け，（かつ，その間にマシンを入れ替えるなどをしないように自分で保証して）動かさないといけない

# うまい使い方集

 * リモート作業: マスターを無線LANにつなげてリモートデスクトップの設定でもしてやれば，サーバルームで作業をする必要はないし，PC全部を手元においておく必要もない．もちろんSSHを設定しても構わない．マスターはDHCPサーバをやっているので一般には，うっかり他のLANに入れてはいけないが，マスターのDHCPはeth0 (有線)に対してのみDHCPサーバとして動作するようになっている(/etc/default/isc-dhcp-server)．もちろんSSHできるよういしてもよい．これらをデフォルトの挙動とするのははばかられたので，やりたければマスター起動後に手作業で設定して下さい．

 * ファイルの修正: マスター上でoutbreakコマンドやらそこから使われているファイルを編集して，バグの修正や機能改善をしても良い．マスター上の /root/pi というフォルダは，pandemic-installer を git clone したものなので，マスター上で直接施した修正をgit にpushしてもよい．逆にファイルの修正は自分のPCなどでcloneしたディレクトリに対して行い，そこから修正をpushし，マスター上でgit pull してもよい．権限の問題を考えると後者のほうが効率的かも知れない．いずれにせよ，小さな修正があるたびにUSBを焼きなおす必要はない．

 * outbreakは汚いシェルスクリプトではあるが，全体としてやっていることは単純で，かつコメントをそれなりにまともに書いているので，精神的ゆとりのあるときに一度読むといい．

 * UI的な部分で不便だと思ったら outbreak の最中に起こっていることは文字通り，本質的にはディスクのコピーだけなので，シェルスクリプトを追って改善することを試みると良いとおもう．

 * そのために，GXPを使いこなすとよい．多くの操作は各クライアントマシン上であるコマンドを実行する，程度のことで実現できる．
```
gxpc e コマンド
```
などを使いこなせばoutbreakをよりナイスなものにしていける
 * 例えば今，各クライアントに進捗やステータスを示す窓を出すようにしている．
 * その仕組みは，
  * master_scripts/S20outbreak/change_status というスクリプトを全クライアントにコピーしておく
  * それを起動すると，各クライアントで窓が出る．change_statusの中では簡単なSVGファイルを作り，eogという画像ビューアを起動してそれを表示している．
  * 遠隔のマシンに窓を出すためにいろいろな小細工が必要．xhost + とか．ただ，このへんがおもうように動かないこともある．
  * もし改善したいと思ったら，gxpc e を用いてクライアント上でコマンドを実行し，それが動くことを確認できたらoutbreakの中に書いていけば良い．


  


